# Deep Dive: ApplyMappingsFromAssembly Method

The `ApplyMappingsFromAssembly` method is the heart of the automatic mapping configuration in the application. Let's break down how it works line by line.

## Method Signature

```csharp
private void ApplyMappingsFromAssembly(Assembly assembly)
```

Takes an Assembly parameter which represents the compiled code of your application.

## Step-by-Step Breakdown

### 1. Setting Up Type References

```csharp
var mapFromType = typeof(IMapFrom<>);
var mappingMethodName = nameof(IMapFrom<object>.Mapping);
```

- `mapFromType`: Gets the type definition of `IMapFrom<>` interface
- `mappingMethodName`: Gets the name of the `Mapping` method ("Mapping")

### 2. Interface Check Helper

```csharp
bool HasInterface(Type t) => t.IsGenericType && t.GetGenericTypeDefinition() == mapFromType;
```

This local function checks if a type implements the `IMapFrom<>` interface:

- `IsGenericType`: Checks if the type is generic
- `GetGenericTypeDefinition()`: Gets the generic type without its type parameters
- Returns true if the type implements `IMapFrom<>`

### 3. Finding Types to Map

```csharp
var types = assembly.GetExportedTypes()
    .Where(t => t.GetInterfaces().Any(HasInterface))
    .ToList();
```

- `GetExportedTypes()`: Gets all public types in the assembly
- Filters types that implement `IMapFrom<>` interface
- Creates a list of these types for processing

### 4. Processing Each Type

```csharp
foreach (var type in types)
{
    var instance = Activator.CreateInstance(type);
```

- Iterates through each type that implements `IMapFrom<>`
- Creates an instance of that type using reflection

### 5. Mapping Configuration Logic

```csharp
var methodInfo = type.GetMethod(mappingMethodName);

if (methodInfo != null)
{
    methodInfo.Invoke(instance, new object[] { this });
}
```

Primary Path:

- Tries to find the `Mapping` method directly on the type
- If found, invokes it passing the current Profile instance

### 6. Fallback Configuration

```csharp
else
{
    var interfaces = type.GetInterfaces().Where(HasInterface).ToList();

    if (interfaces.Count > 0)
    {
        foreach (var @interface in interfaces)
        {
            var interfaceMethodInfo = @interface.GetMethod(mappingMethodName, argumentTypes);
            interfaceMethodInfo?.Invoke(instance, new object[] { this });
        }
    }
}
```

Fallback Path:

- If no direct method is found, looks for the method in the interfaces
- Gets all interfaces that inherit from `IMapFrom<>`
- For each interface, tries to find and invoke the `Mapping` method

## Why This Approach?

1. **Flexibility**: Supports both default and custom mapping configurations

   - Default: Uses the basic implementation from `IMapFrom<T>`
   - Custom: Allows classes to override the `Mapping` method

2. **Automation**: No manual registration required

   - Automatically discovers all mapping configurations
   - Reduces the chance of forgetting to register a mapping

3. **Maintainability**:

   - Central location for all mapping configurations
   - Easy to debug as all mappings are discovered in one place

4. **Performance**:
   - Mappings are discovered once at startup
   - No runtime reflection overhead during normal operation

## Example Flow

Let's say you have this class:

```csharp
public class BlogVm : IMapFrom<Blog>
{
    public int Id { get; set; }
    public string Title { get; set; }
}
```

The method will:

1. Find `BlogVm` as it implements `IMapFrom<>`
2. Create an instance of `BlogVm`
3. Look for a `Mapping` method on `BlogVm`
4. If not found, use the default implementation from `IMapFrom<Blog>`
5. Configure the mapping from `Blog` to `BlogVm`

This approach ensures that all your mappings are configured correctly at application startup, making your application more robust and easier to maintain.
