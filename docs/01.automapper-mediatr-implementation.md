# Understanding AutoMapper and MediatR Implementation

This document explains the implementation of AutoMapper and MediatR in the Clean Architecture solution, breaking down each component and its purpose.

## AutoMapper Implementation

### 1. IMapFrom<T> Interface

```csharp
public interface IMapFrom<T>
{
    void Mapping(Profile profile) => profile.CreateMap(typeof(T), destinationType: GetType());
}
```

This interface serves as a contract for automatic mapping configuration:

- It's a generic interface where `T` represents the source type to map from
- Provides a default implementation of `Mapping` method using AutoMapper's `Profile`
- Any class implementing this interface will automatically get mapping configured from type `T` to itself

### 2. MappingProfile Class

The `MappingProfile` class is the core configuration class for AutoMapper that automatically discovers and configures all mappings in the assembly.

Key aspects:

- Inherits from AutoMapper's `Profile` class
- Uses reflection to scan the assembly for mapping configurations
- Automatically configures mappings for all classes implementing `IMapFrom<T>`

How it works:

1. In the constructor, it calls `ApplyMappingsFromAssembly` with the current assembly
2. The method finds all types implementing `IMapFrom<T>`
3. For each type found:
   - Creates an instance of the type
   - Looks for the `Mapping` method
   - If found, invokes it directly
   - If not found, looks for the method in the interfaces and invokes it there

## Usage Example

From your `GetBlogQueryHandler`, we can see the practical application:

```csharp
return _mapper.Map<List<BlogVm>>(blogs);
```

This line transforms the domain entities to view models using the configured mappings.

## Dependency Injection Setup

The `DependencyInjection` class configures both AutoMapper and MediatR:

```csharp
public static IServiceCollection AddApplicationDI(this IServiceCollection services)
{
    services.AddAutoMapper(Assembly.GetExecutingAssembly());
    services.AddMediatR(ctg =>
    {
        ctg.RegisterServicesFromAssembly(Assembly.GetExecutingAssembly());
    });
    return services;
}
```

This setup:

1. Registers AutoMapper with all profiles from the current assembly
2. Registers MediatR with all handlers from the current assembly

## Benefits of This Implementation

1. **Automatic Mapping Discovery**

   - No need to manually register each mapping
   - Reduces boilerplate code
   - Follows convention over configuration principle

2. **Type Safety**

   - Mapping configurations are checked at startup
   - Compile-time type checking through generic constraints

3. **Clean Architecture Support**

   - Clear separation of concerns
   - Easy to maintain and extend
   - Follows SOLID principles

4. **Standardized Approach**
   - Consistent way to implement mappings across the application
   - Easy for new developers to understand and follow the pattern

## How to Add New Mappings

To create a new mapping:

1. Create your destination class (e.g., DTO or ViewModel)
2. Implement `IMapFrom<T>` interface:

```csharp
public class BlogVm : IMapFrom<Blog>
{
    public int Id { get; set; }
    public string Name { get; set; }
    // ... other properties
}
```

3. Optionally, override the `Mapping` method for custom configurations:

```csharp
public void Mapping(Profile profile)
{
    profile.CreateMap<Blog, BlogVm>()
        .ForMember(d => d.CustomProperty, opt => opt.MapFrom(s => s.SourceProperty));
}
```

The mapping will be automatically discovered and configured at startup.
